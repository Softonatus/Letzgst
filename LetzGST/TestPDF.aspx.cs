using iTextSharp.text;
using iTextSharp.text.html;
using iTextSharp.text.html.simpleparser;
using iTextSharp.text.pdf;
using iTextSharp.tool.xml;
using iTextSharp.tool.xml.parser;
using iTextSharp.tool.xml.pipeline.css;
using iTextSharp.tool.xml.pipeline.end;
using iTextSharp.tool.xml.pipeline.html;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Mail;
using System.Text;
using System.Web;
using System.Web.UI;

namespace LetzGST
{
    public partial class TestPDF : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            //byte[] pdf;
            //var cssText = File.ReadAllText(MapPath("~/css/main.css"));
            //var html = File.ReadAllText(MapPath("/testpdf.html"));

            //using (var memoryStream = new MemoryStream())
            //{
            //    var document = new Document(PageSize.A4);
            //    var writer = PdfWriter.GetInstance(document, memoryStream);
            //    document.Open();

            //    using (var cssMemoryStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(cssText)))
            //    {
            //        using (var htmlMemoryStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(html)))
            //        {
            //            XMLWorkerHelper.GetInstance().ParseXHtml(writer, document, htmlMemoryStream, cssMemoryStream);
            //        }
            //    }

            //    document.Close();

            //    pdf = memoryStream.ToArray();

            //    memoryStream.Close();

            //    // Clears all content output from the buffer stream
            //    Response.Clear();
            //    // Gets or sets the HTTP MIME type of the output stream.
            //    Response.ContentType = "application/pdf";
            //    // Adds an HTTP header to the output stream
            //    Response.AddHeader("Content-Disposition", "attachment; filename=Invoice.pdf");

            //    //Gets or sets a value indicating whether to buffer output and send it after
            //    // the complete response is finished processing.
            //    Response.Buffer = true;
            //    // Sets the Cache-Control header to one of the values of System.Web.HttpCacheability.
            //    Response.Cache.SetCacheability(HttpCacheability.NoCache);
            //    // Writes a string of binary characters to the HTTP output stream. it write the generated bytes .
            //    Response.BinaryWrite(pdf);
            //    // Sends all currently buffered output to the client, stops execution of the
            //    // page, and raises the System.Web.HttpApplication.EndRequest event.

            //    Response.End();
            //    // Closes the socket connection to a client. it is a necessary step as you must close the response after doing work.its best approach.
            //    Response.Close();
            }


        //protected void btnExport_Click(object sender, EventArgs e)
        //{
        //    using (var pdfDoc = new Document(PageSize.A4))
        //    {
        //        PdfWriter.GetInstance(pdfDoc, new FileStream("Test.pdf", FileMode.Create));
        //        pdfDoc.Open();

        //        FontFactory.Register("c:\\windows\\fonts\\tahoma.ttf");

        //        var tags = new HTMLTagProcessors();
        //        // Replace the built-in image processor
        //        tags[HtmlTags.IMG] = new CustomImageHTMLTagProcessor();

        //        StringWriter sw = new StringWriter();
        //        HtmlTextWriter hw = new HtmlTextWriter(sw);
        //        this.Page.RenderControl(hw);
        //        StringReader sr = new StringReader(sw.ToString());

        //        //var html = sr; //"<img alt='' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAodJREFUeNpsk0tME1EUhv87UwlCREhRFpi4cGMMRrTE4MaoxBhAsDyMssFHfCQu3BlXGuNKNy5NmqALoqEEMJWCgEUjYojllSpofIUNBNqmIKU6OnQennunUxvgJF86957z/+d27hkGigMlDJfOAmV7AcYsKGqIZljRSvhNE+CMTwEtXmBy2gQb7mCQJUBKkTIQYtfJYCNMAxO9hzq5CYmFiWFY6ISE9VFLRedc1SONeqwf+uJLuKreNPI9nltbLG0orhpqUCM90DRVoEbJ5MSLho1MMg1O0bHOuyoD9crCcxL+xa0HqwL+rEQHsb/CW89reO1aAyEuq+yp+zXvg66rgng8LrDXSmwYpUc8dZkmDsJNL+NCeVVXbWK+O32cpJ7E6OgkwuEwrl8phaHrVsfYD+x03XTPjN3nzZnD0HGxvPppTSLcLwo0I4lldRFK8jdCoZBlJquAbBnr0BD9GUTRvubahclW5qDukqkpIqlodGQ1At3UxZXaIUvauqsyjBV+jZJEJ3s83HO5j+UWI7E6C4mp2EQCTixyV2CvbbKzNmN2zNfHtbzPM3p4FOy/M5CXtwsOKZmmsOi2IHMvyyFhJhgY4BqutQ/aRRstocEngZzswnQnO+x1lqTjy8hIgNdyDc+x5nomxrKJhpcSp2lSrx48WlZhGArynG5hsLLoE7/jQ59f0aR7ZBkdbf7U6Ge+mKYaBvdx8wwZXjtWvfswfTrp3Over29J8NAXYO1t/v/7csZA5U5/Q35nH+aKt8OMR2POPSUFOyRmorvje3BiCt4b9zBANTmwGvP/aMoZRluJbURB8APmnPlQliNLzk8flxbeh9Du8eId5bYQ2SnxH36b/wQYABNFRsIaESsTAAAAAElFTkSuQmCC' />";

        //        var styles = new StyleSheet();
        //        styles.LoadTagStyle(HtmlTags.BODY, HtmlTags.FONTFAMILY, "tahoma");
        //        styles.LoadTagStyle(HtmlTags.BODY, HtmlTags.ENCODING, "Identity-H");

        //        PdfPCell pdfCell = new PdfPCell { Border = 0 };
        //        pdfCell.RunDirection = PdfWriter.RUN_DIRECTION_LTR;

        //        using (var reader = new StringReader(sw.ToString()))
        //        {
        //            var parsedHtmlElements = HTMLWorker.ParseToList(reader, styles, tags, null);

        //            foreach (var htmlElement in parsedHtmlElements)
        //            {
        //                pdfCell.AddElement(htmlElement);
        //            }
        //        }

        //        var table1 = new PdfPTable(1);
        //        table1.AddCell(pdfCell);
        //        pdfDoc.Add(table1);
        //    }

        //    Process.Start("Test.pdf");
        //}


        //Response.ContentType = "application/pdf";
        //Response.AddHeader("content-disposition", "attachment;filename=TestPage.pdf");
        //Response.Cache.SetCacheability(HttpCacheability.NoCache);
        //StringWriter sw = new StringWriter();
        //HtmlTextWriter hw = new HtmlTextWriter(sw);
        //this.Page.RenderControl(hw);
        //StringReader sr = new StringReader(sw.ToString());
        //Document pdfDoc = new Document(PageSize.A4, 10f, 10f, 100f, 0f);
        //HTMLWorker htmlparser = new HTMLWorker(pdfDoc);
        //PdfWriter.GetInstance(pdfDoc, Response.OutputStream);
        //pdfDoc.Open();
        //htmlparser.Parse(sr);
        //pdfDoc.Close();
        //Response.Write(pdfDoc);
        //Response.End();


        protected void btnExport_Click(object sender, EventArgs e)
        {
            FontFactory.RegisterDirectories();
            StringWriter sw = new StringWriter();
            HtmlTextWriter hw = new HtmlTextWriter(sw);
            this.Page.RenderControl(hw);
            //StringReader sr = new StringReader(sw.ToString());
            var inputString = sw.ToString();

            List<string> cssFiles = new List<string>();
            cssFiles.Add(@"/css/pdf.css");

            var output = new MemoryStream();

            var input = new MemoryStream(Encoding.UTF8.GetBytes(inputString));

            var document = new Document(PageSize.A4, 50, 50, 25, 25);
            var writer = PdfWriter.GetInstance(document, output);
            writer.CloseStream = false;

            document.Open();
            var htmlContext = new HtmlPipelineContext(null);
            htmlContext.SetTagFactory(iTextSharp.tool.xml.html.Tags.GetHtmlTagProcessorFactory());

            ICSSResolver cssResolver = XMLWorkerHelper.GetInstance().GetDefaultCssResolver(true);
            cssFiles.ForEach(i => cssResolver.AddCssFile(System.Web.HttpContext.Current.Server.MapPath(i), true));

            var pipeline = new CssResolverPipeline(cssResolver, new HtmlPipeline(htmlContext, new PdfWriterPipeline(document, writer)));
            var worker = new XMLWorker(pipeline, true);
            var p = new XMLParser(worker);
            using (var stringReader = new StringReader(sw.ToString()))
            {
                p.Parse(stringReader);
            }
            //p.Parse(input);
            document.Close();
            output.Position = 0;


            Response.Clear();
            Response.ContentType = "application/pdf";
            Response.AddHeader("Content-Disposition", "attachment; filename=myfile.pdf");
            Response.BinaryWrite(output.ToArray());
            // myMemoryStream.WriteTo(Response.OutputStream); //works too
            Response.Flush();
            Response.Close();
            Response.End();

        }
    }

    //}

    

}

public class CustomImageHTMLTagProcessor : IHTMLTagProcessor
    {
        /// <summary>
        /// Tells the HTMLWorker what to do when a close tag is encountered.
        /// </summary>
        public void EndElement(HTMLWorker worker, string tag)
        {
        }

        /// <summary>
        /// Tells the HTMLWorker what to do when an open tag is encountered.
        /// </summary>
        public void StartElement(HTMLWorker worker, string tag, IDictionary<string, string> attrs)
        {
            Image image;
            var src = attrs["src"];

            if (src.StartsWith("data:image/"))
            {
                // data:[<MIME-type>][;charset=<encoding>][;base64],<data>
                var base64Data = src.Substring(src.IndexOf(",") + 1);
                var imagedata = Convert.FromBase64String(base64Data);
                image = Image.GetInstance(imagedata);
            }
            else
            {
                image = Image.GetInstance(src);
            }

            worker.UpdateChain(tag, attrs);
            worker.ProcessImage(image, attrs);
            worker.UpdateChain(tag);
        }
    }

